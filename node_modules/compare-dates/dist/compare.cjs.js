'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function isValidDate (input) {
  return input instanceof Date && !isNaN(input.getTime());
}

const aliases = {};

function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

addUnitAlias('month', 'M');
addUnitAlias('year', 'y');
addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');
addUnitAlias('quarter', 'Q');
addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');
addUnitAlias('date', 'D');
addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');
addUnitAlias('dayOfYear', 'DDD');
addUnitAlias('hour', 'h');
addUnitAlias('minute', 'm');
addUnitAlias('second', 's');
addUnitAlias('millisecond', 'ms');
function normalizeUnits(units) {
  return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function setMonth(date, month) {
  const dayOfMonth = Math.min(date.getDate(), daysInMonth(date.getFullYear(), month));
  date.setMonth(month, dayOfMonth);
}
function daysInMonth(year, month) {
  return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}
function setDayOfWeek(date, input) {
  const day = date.getDay();
  date.setDate(date.getDate() + input - day);
}

function Duration(duration) {
  var years = duration.year || 0,
      quarters = duration.quarter || 0,
      months = duration.month || 0,
      weeks = duration.week || 0,
      days = duration.day || 0,
      hours = duration.hour || 0,
      minutes = duration.minute || 0,
      seconds = duration.second || 0,
      milliseconds = duration.millisecond || 0; // representation for dateAddRemove

  this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
  minutes * 6e4 + // 1000 * 60
  hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
  // Because of dateAddRemove treats 24 hours as different from a
  // day when working around DST, we need to store them separately

  this._days = +days + weeks * 7; // It is impossible translate months into days without knowing
  // which months you are are talking about, so we have to store
  // it separately.

  this._months = +months + quarters * 3 + years * 12;
}

function createDuration(input, key) {
  const duration = {};

  if (key) {
    duration[normalizeUnits(key)] = input;
  } else {
    duration.millisecond = input;
  }

  return new Duration(duration);
}

function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}

function createAdder(direction) {
  return function (date, val, period) {
    const duration = createDuration(val, period);
    return addSubtract(date, duration, direction);
  };
}

function addSubtract(original, duration, isAdding) {
  const date = new Date(original.valueOf());
  const milliseconds = duration._milliseconds;
  const days = absRound(duration._days);
  const months = absRound(duration._months);

  if (milliseconds) {
    date.setTime(date.valueOf() + milliseconds * isAdding);
  }

  if (days) {
    date.setDate(date.getDate() + days * isAdding); //set(mom, 'Date', get(mom, 'Date') + days * isAdding);
  }

  if (months) {
    setMonth(date, date.getMonth() + months * isAdding);
  }

  return date;
}

const add = createAdder(1);
const subtract = createAdder(-1);

function startOf(date, units) {
  units = normalizeUnits(units);
  const modified = new Date(date.valueOf()); // the following switch intentionally omits break keywords
  // to utilize falling through the cases.

  switch (units) {
    case 'year':
      setMonth(modified, 0);

    /* falls through */

    case 'quarter':
    case 'month':
      modified.setDate(1);

    /* falls through */

    case 'week':
    case 'day':
    case 'date':
      modified.setHours(0);

    /* falls through */

    case 'hour':
      modified.setMinutes(0);

    /* falls through */

    case 'minute':
      modified.setSeconds(0);

    /* falls through */

    case 'second':
      modified.setMilliseconds(0);
  } // weeks are a special case


  if (units === 'week') {
    setDayOfWeek(modified, 1);
  } // quarters are also special


  if (units === 'quarter') {
    setMonth(modified, Math.floor(modified.getMonth() / 3) * 3);
  }

  return modified;
}
function endOf(date, units) {
  units = normalizeUnits(units);

  if (units === undefined || units === 'millisecond') {
    return new Date(date.valueOf());
  } // 'date' is an alias for 'day', so it should be considered as such.


  if (units === 'date') {
    units = 'day';
  }

  let modified = startOf(date, units);
  modified = add(modified, 1, units);
  modified = subtract(modified, 1, 'ms');
  return modified;
}

function isAfter(first, second, units) {
  if (!isValidDate(first) || !isValidDate(second)) {
    throw new Error('Invalid date');
  }

  units = normalizeUnits(units || 'millisecond');

  if (units === 'millisecond') {
    return first > second;
  } else {
    return second.valueOf() < startOf(first, units).valueOf();
  }
}
function isBefore(first, second, units) {
  if (!isValidDate(first) || !isValidDate(second)) {
    throw new Error('Invalid date');
  }

  units = normalizeUnits(units || 'millisecond');

  if (units === 'millisecond') {
    return first < second;
  } else {
    return endOf(first, units).valueOf() < second.valueOf();
  }
}
function isBetween(date, from, to, units, inclusivity) {
  inclusivity = inclusivity || '()';
  return (inclusivity[0] === '(' ? isAfter(date, from, units) : !isBefore(date, from, units)) && (inclusivity[1] === ')' ? isBefore(date, to, units) : !isAfter(date, to, units));
}
function isSame(date, input, units) {
  if (!isValidDate(date) || !isValidDate(input)) {
    throw new Error('Invalid date');
  }

  units = normalizeUnits(units || 'millisecond');

  if (units === 'millisecond') {
    return date.getTime() === input.getTime();
  } else {
    const inputMs = input.valueOf();
    return startOf(date, units).valueOf() <= inputMs && inputMs <= endOf(date, units).valueOf();
  }
}
function isSameOrAfter(date, input, units) {
  return isSame(date, input, units) || isAfter(date, input, units);
}
function isSameOrBefore(date, input, units) {
  return isSame(date, input, units) || isBefore(date, input, units);
}

function pickBy(fn, moments) {
  var res, i;

  if (!moments.length) {
    return new Date();
  }

  res = moments[0];

  for (i = 1; i < moments.length; ++i) {
    if (!isValidDate(moments[i])) {
      throw new Error('Invalid date');
    } else if (fn(moments[i], res)) {
      res = moments[i];
    }
  }

  return res;
}

function min(...dates) {
  return pickBy(isBefore, dates);
}
function max(...dates) {
  return pickBy(isAfter, dates);
}

function diff(first, second, units, asFloat) {
  let output;

  if (!isValidDate(first) || !isValidDate(second)) {
    throw new Error('Invalid date');
  }

  units = normalizeUnits(units);

  if (units === 'year' || units === 'month' || units === 'quarter') {
    output = monthDiff(first, second);

    if (units === 'quarter') {
      output = output / 3;
    } else if (units === 'year') {
      output = output / 12;
    }
  } else {
    const delta = first - second;
    output = units === 'second' ? delta / 1e3 : // 1000
    units === 'minute' ? delta / 6e4 : // 1000 * 60
    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
    units === 'day' ? delta / 864e5 : // 1000 * 60 * 60 * 24, negate dst
    units === 'week' ? delta / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
    delta;
  }

  return asFloat ? output : absFloor(output);
}

function absFloor(number) {
  if (number < 0) {
    // -0 -> 0
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}

function monthDiff(a, b) {
  // difference in months
  var wholeMonthDiff = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth()),
      // b is in (anchor - 1 month, anchor + 1 month)
  anchor = add(a, wholeMonthDiff, 'months'),
      anchor2,
      adjust;

  if (b - anchor < 0) {
    anchor2 = add(a, wholeMonthDiff - 1, 'months'); // linear across the month

    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = add(a, wholeMonthDiff + 1, 'months'); // linear across the month

    adjust = (b - anchor) / (anchor2 - anchor);
  } //check for negative zero, return zero if negative zero


  return -(wholeMonthDiff + adjust) || 0;
}

exports.add = add;
exports.diff = diff;
exports.endOf = endOf;
exports.isAfter = isAfter;
exports.isBefore = isBefore;
exports.isBetween = isBetween;
exports.isSame = isSame;
exports.isSameOrAfter = isSameOrAfter;
exports.isSameOrBefore = isSameOrBefore;
exports.max = max;
exports.min = min;
exports.startOf = startOf;
exports.subtract = subtract;
